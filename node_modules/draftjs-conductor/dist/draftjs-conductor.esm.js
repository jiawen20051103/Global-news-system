import getContentStateFragment from 'draft-js/lib/getContentStateFragment';
import getDraftEditorSelection from 'draft-js/lib/getDraftEditorSelection';
import editOnCopy from 'draft-js/lib/editOnCopy';
import editOnCut from 'draft-js/lib/editOnCut';
import { convertFromRaw, Modifier, EditorState, ContentState, convertToRaw } from 'draft-js';

// Default maximum block depth supported by Draft.js CSS.
const DRAFT_DEFAULT_MAX_DEPTH = 4;
// Default depth class prefix from Draft.js CSS.
const DRAFT_DEFAULT_DEPTH_CLASS = "public-DraftStyleDefault-depth";
/**
 * Matching the counter styles of Google Docs and Draft.js v0.11.
 * See https://github.com/facebook/draft-js/commit/d2a3ae8.
 */
const COUNTER_STYLES = ["decimal", "lower-alpha", "lower-roman"];
/**
 * Generates CSS styles for list items, for a given selector pattern.
 * @deprecated Use getListNestingStyles instead, which has the same signature.
 * @param {string} selectorPrefix
 * @param {number} minDepth
 * @param {number} maxDepth
 * @param {Array} counterStyles
 */
const generateListNestingStyles = (selectorPrefix, minDepth, maxDepth, counterStyles) => {
    let styles = `
.${selectorPrefix}1.public-DraftStyleDefault-orderedListItem::before { content: counter(ol1, ${counterStyles[1 % counterStyles.length]}) ". "}
.${selectorPrefix}2.public-DraftStyleDefault-orderedListItem::before { content: counter(ol2, ${counterStyles[2 % counterStyles.length]}) ". "}
.${selectorPrefix}4.public-DraftStyleDefault-orderedListItem::before { content: counter(ol4, ${counterStyles[4 % counterStyles.length]}) ". "}
`;
    for (let depth = minDepth; depth <= maxDepth; depth++) {
        const d = String(depth);
        const prefix = `${selectorPrefix}${d}`;
        const counter = `ol${d}`;
        const counterStyle = counterStyles[depth % counterStyles.length];
        const margin = 1.5 * (depth + 1);
        const m = String(margin);
        styles += `
.${prefix}.public-DraftStyleDefault-listLTR { margin-left: ${m}em; }
.${prefix}.public-DraftStyleDefault-listRTL { margin-right: ${m}em; }
.${prefix}.public-DraftStyleDefault-orderedListItem::before { content: counter(${counter}, ${counterStyle}) '. '; counter-increment: ${counter}; }
.${prefix}.public-DraftStyleDefault-reset { counter-reset: ${counter}; }`;
    }
    return styles;
};
/**
 * Dynamically generates the right list nesting styles.
 * Can be wrapped as a pure component - to re-render only when `max` changes (eg. never).
 */
const getListNestingStyles = (maxDepth, minDepth = DRAFT_DEFAULT_MAX_DEPTH + 1, selectorPrefix = DRAFT_DEFAULT_DEPTH_CLASS, counterStyles = COUNTER_STYLES) => {
    return generateListNestingStyles(selectorPrefix, minDepth, maxDepth, counterStyles);
};
/**
 * Add depth classes that Draft.js doesn't provide.
 * See https://github.com/facebook/draft-js/blob/232791a4e92d94a52c869f853f9869367bdabdac/src/component/contents/DraftEditorContents-core.react.js#L58-L62.
 * @param {ContentBlock} block
 */
const blockDepthStyleFn = (block) => {
    const depth = block.getDepth();
    return depth > DRAFT_DEFAULT_MAX_DEPTH
        ? `${DRAFT_DEFAULT_DEPTH_CLASS}${String(depth)}`
        : "";
};

// @ts-expect-error
// Custom attribute to store Draft.js content in the HTML clipboard.
const FRAGMENT_ATTR = "data-draftjs-conductor-fragment";
const DRAFT_DECORATOR = '[data-contents="true"] [contenteditable="false"]';
// Checks whether the selection is inside a decorator or not.
// This is important to change the copy-cut behavior accordingly.
const isSelectionInDecorator = (selection) => {
    const { anchorNode, focusNode } = selection;
    if (!anchorNode || !focusNode) {
        return false;
    }
    const anchor = anchorNode instanceof Element ? anchorNode : anchorNode.parentElement;
    const focus = focusNode instanceof Element ? focusNode : focusNode.parentElement;
    const anchorDecorator = anchor && anchor.closest(DRAFT_DECORATOR);
    const focusDecorator = focus && focus.closest(DRAFT_DECORATOR);
    return (anchorDecorator &&
        focusDecorator &&
        (anchorDecorator.contains(focusDecorator) ||
            focusDecorator.contains(anchorDecorator)));
};
// Get clipboard content from the selection like Draft.js would.
const getSelectedContent = (editorState, editorRoot) => {
    const { selectionState } = getDraftEditorSelection(editorState, editorRoot);
    const fragment = getContentStateFragment(editorState.getCurrentContent(), selectionState);
    // If the selection contains no content (according to Draft.js), use the default browser behavior.
    // This happens when selecting text that's within contenteditable=false blocks in Draft.js.
    // See https://github.com/thibaudcolas/draftjs-conductor/issues/12.
    const isEmpty = fragment.every((block) => {
        return block.getText().length === 0;
    });
    return isEmpty ? null : fragment;
};
// Overrides the default copy/cut behavior, adding the serialised Draft.js content to the clipboard data.
// See also https://github.com/basecamp/trix/blob/62145978f352b8d971cf009882ba06ca91a16292/src/trix/controllers/input_controller.coffee#L415-L422
// We serialise the editor content within HTML, not as a separate mime type, because Draft.js only allows access
// to HTML in its paste event handler.
const draftEditorCopyCutListener = (
// @ts-expect-error
ref, e) => {
    const selection = window.getSelection();
    // Completely skip event handling if clipboardData is not supported (IE11 is out).
    // Also skip if there is no selection ranges.
    // Or if the selection is fully within a decorator.
    if (!e.clipboardData ||
        selection.rangeCount === 0 ||
        isSelectionInDecorator(selection)) {
        return;
    }
    // @ts-expect-error
    const fragment = getSelectedContent(ref._latestEditorState, ref.editor);
    // Override the default behavior if there is selected content.
    if (fragment) {
        const content = ContentState.createFromBlockArray(fragment.toArray());
        const serialisedContent = JSON.stringify(convertToRaw(content));
        // Create a temporary element to store the selectionâ€™s HTML.
        // See also Rangy's implementation: https://github.com/timdown/rangy/blob/1e55169d2e4d1d9458c2a87119addf47a8265276/src/core/domrange.js#L515-L520.
        const fragmentElt = document.createElement("div");
        // Modern browsers only support a single range.
        fragmentElt.appendChild(selection.getRangeAt(0).cloneContents());
        fragmentElt.setAttribute(FRAGMENT_ATTR, serialisedContent);
        // We set the style property to replicate the browser's behavior of inline styles in rich text copy-paste.
        // In Draft.js, this is important for line breaks to be interpreted correctly when pasted into another word processor.
        // See https://github.com/facebook/draft-js/blob/a1f4593d8fa949954053e5d5840d33ce1d1082c6/src/component/base/DraftEditor.react.js#L328.
        fragmentElt.setAttribute("style", "white-space: pre-wrap;");
        e.clipboardData.setData("text/plain", selection.toString());
        e.clipboardData.setData("text/html", fragmentElt.outerHTML);
        e.preventDefault();
    }
};
const onDraftEditorCopy = (editor, e) => {
    // @ts-expect-error
    draftEditorCopyCutListener(editor, e);
    editOnCopy(editor, e);
};
const onDraftEditorCut = (editor, e) => {
    // @ts-expect-error
    draftEditorCopyCutListener(editor, e);
    editOnCut(editor, e);
};
/**
 * Registers custom copy/cut event listeners on an editor.
 */
// @ts-expect-error
const registerCopySource = (ref) => {
    // @ts-expect-error
    const editorElt = ref.editor;
    const onCopyCut = draftEditorCopyCutListener.bind(null, ref);
    editorElt.addEventListener("copy", onCopyCut);
    editorElt.addEventListener("cut", onCopyCut);
    return {
        unregister() {
            editorElt.removeEventListener("copy", onCopyCut);
            editorElt.removeEventListener("cut", onCopyCut);
        },
    };
};
/**
 * Returns pasted content coming from Draft.js editors set up to serialise
 * their Draft.js content within the HTML.
 */
const getDraftEditorPastedContent = (html) => {
    // Plain-text pastes are better handled by Draft.js.
    if (html === "" || typeof html === "undefined" || html === null) {
        return null;
    }
    const doc = new DOMParser().parseFromString(html, "text/html");
    const fragmentElt = doc.querySelector(`[${FRAGMENT_ATTR}]`);
    // Handle the paste if it comes from draftjs-conductor.
    if (fragmentElt) {
        const fragmentAttr = fragmentElt.getAttribute(FRAGMENT_ATTR);
        let rawContent;
        try {
            // If JSON parsing fails, leave paste handling to Draft.js.
            // There is no reason for this to happen, unless the clipboard was altered somehow.
            // @ts-expect-error
            rawContent = JSON.parse(fragmentAttr);
        }
        catch (error) {
            return null;
        }
        return convertFromRaw(rawContent);
    }
    return null;
};
/**
 * Handles pastes coming from Draft.js editors set up to serialise
 * their Draft.js content within the HTML.
 * This SHOULD NOT be used for stripPastedStyles editor.
 */
const handleDraftEditorPastedText = (html, editorState) => {
    const pastedContent = getDraftEditorPastedContent(html);
    if (pastedContent) {
        const fragment = pastedContent.getBlockMap();
        const content = Modifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);
        return EditorState.push(editorState, content, "insert-fragment");
    }
    return false;
};

const EMPTY_CONTENT_STATE = null;
/**
 * Creates a new EditorState from a RawDraftContentState, or an empty editor state by
 * passing `null`. Optionally takes a decorator.
 */
const createEditorStateFromRaw = (rawContentState, decorator) => {
    let editorState;
    if (rawContentState) {
        const contentState = convertFromRaw(rawContentState);
        editorState = EditorState.createWithContent(contentState, decorator);
    }
    else {
        editorState = EditorState.createEmpty(decorator);
    }
    return editorState;
};
/**
 * Serialises the editorState using `convertToRaw`, but returns `null` if
 * the editor content is empty (no text, entities, styles).
 */
const serialiseEditorStateToRaw = (editorState) => {
    const contentState = editorState.getCurrentContent();
    const rawContentState = convertToRaw(contentState);
    const isEmpty = rawContentState.blocks.every((block) => {
        const isEmptyBlock = block.text.trim().length === 0 &&
            (!block.entityRanges || block.entityRanges.length === 0) &&
            (!block.inlineStyleRanges || block.inlineStyleRanges.length === 0);
        return isEmptyBlock;
    });
    return isEmpty ? EMPTY_CONTENT_STATE : rawContentState;
};

export { DRAFT_DEFAULT_DEPTH_CLASS, DRAFT_DEFAULT_MAX_DEPTH, blockDepthStyleFn, createEditorStateFromRaw, generateListNestingStyles, getDraftEditorPastedContent, getListNestingStyles, handleDraftEditorPastedText, onDraftEditorCopy, onDraftEditorCut, registerCopySource, serialiseEditorStateToRaw };
